"use strict";(self.webpackChunkrocketmq_docs=self.webpackChunkrocketmq_docs||[]).push([[2539],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var o=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,s=function(e,t){if(null==e)return{};var n,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=c(n),p=s,d=h["".concat(l,".").concat(p)]||h[p]||m[p]||r;return n?o.createElement(d,a(a({ref:t},u),{},{components:n})):o.createElement(d,a({ref:t},u))}));function p(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,a=new Array(r);a[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,a[1]=i;for(var c=2;c<r;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},10608:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var o=n(87462),s=(n(67294),n(3905));const r={},a="Core Concept",i={unversionedId:"consumer/11concept2",id:"consumer/11concept2",title:"Core Concept",description:"RocketMQ's messages will be sent to a Topic by a Producer, and a corresponding Consumer should be created to subscribe to the Topic and consume the messages within it. Before introducing the usage of Consumers, we will first clarify the concepts of Consumer Group, Consumer Offset, Push and Pull mode, etc.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/03-consumer/11concept2.md",sourceDirName:"03-consumer",slug:"/consumer/11concept2",permalink:"/docs/4.x/consumer/11concept2",draft:!1,editUrl:"https://github.com/apache/rocketmq-site/tree/new-official-website/docs/03-consumer/11concept2.md",tags:[],version:"current",frontMatter:{},sidebar:"myAutogeneratedSidebar",previous:{title:"Transactional Message Sending",permalink:"/docs/4.x/producer/09message5"},next:{title:"Push Consume",permalink:"/docs/4.x/consumer/12push"}},l={},c=[{value:"Consumer and Consumer Group",id:"consumer-and-consumer-group",level:2},{value:"Load Balancing",id:"load-balancing",level:2},{value:"Consumer Offset",id:"consumer-offset",level:2},{value:"Push, Pull, and Long Polling",id:"push-pull-and-long-polling",level:2}],u={toc:c};function m(e){let{components:t,...r}=e;return(0,s.kt)("wrapper",(0,o.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"core-concept"},"Core Concept"),(0,s.kt)("p",null,"RocketMQ's messages will be sent to a Topic by a Producer, and a corresponding Consumer should be created to subscribe to the Topic and consume the messages within it. Before introducing the usage of Consumers, we will first clarify the concepts of Consumer Group, Consumer Offset, Push and Pull mode, etc."),(0,s.kt)("h2",{id:"consumer-and-consumer-group"},"Consumer and Consumer Group"),(0,s.kt)("p",null,"One of the essential roles of the messaging system is to shave peaks and fill valleys. However, take the e-commerce scenario as an example, if the downstream Consumers do not have enough ability to consume messages, a large amount of transient traffic entering will pile the messages up on the server side. At this point, the end-to-end delay of the message (the time from a message being sent until being consumed) will increase. In addition, for the server side, continuing consuming historical data might generate cold reads. Therefore, the consumption ability needs to be improved to solve this problem, besides optimizing the time of message consumption, the simplest way is to expand the capacity of the Consumer."),(0,s.kt)("p",null,"However, is it possible to increase the consumption ability by adding a random number of Consumers? First of all, the Consumer Group plays an essential role on the Consumer side. Multiple Consumers will be regarded as being in the same Consumer Group if they have the same Consumer Group set up."),(0,s.kt)("p",null,"There are two consumption modes in Apache RocketMQ, which are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Clustering: While applying the Clustering mode, each message requires to be processed by one consumer within the Consumer Group."),(0,s.kt)("li",{parentName:"ul"},"Broadcasting: While applying the Broadcasting mode, RocketMQ broadcasts each message to all Consumers within the Consumer Group, ensuring that the message is consumed at least once by each consumer.")),(0,s.kt)("p",null,"The Clustering mode is suitable for scenarios where each message only needs to be processed once, which means the entire Consumer Group will receive the full amount of messages from Topic, and the Consumers within the Consumer Group share the consumption of these messages. Thus, the consumption ability can be increased or decreased by expanding or shrinking the number of consumers, as shown in the following figure, which is the most common consumption method."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"\u96c6\u7fa4\u6d88\u8d39\u6a21\u5f0f",src:n(28068).Z,width:"1336",height:"753"})),(0,s.kt)("p",null,"The Broadcasting mode is suitable for scenarios where each message needs to be processed by every consumer in the Consumer Group, which means that each consumer in the Consumer Group receives the full amount of messages from the subscribed Topic. Thus, even if the number of consumers is expanded, the consumption ability cannot be enhanced or reduced, as shown in the following example."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"\u5e7f\u64ad\u6d88\u8d39\u6a21\u5f0f",src:n(77041).Z,width:"1398",height:"826"})),(0,s.kt)("h2",{id:"load-balancing"},"Load Balancing"),(0,s.kt)("p",null,"What is the allocation strategy under the Clustering mode where Consumers within the same Consumer Group share the full volume of messages received? Does it necessarily improve consumption ability if the number of consumers expands?"),(0,s.kt)("p",null,"Apache RocketMQ provides various allocation policies in the Clustering mode, including average allocation strategy, machine room priority allocation strategy, consistent hash allocation strategy, etc. You can set the corresponding load balancing strategy by the following code:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"consumer.setAllocateMessageQueueStrategy(new AllocateMessageQueueAveragely());\n")),(0,s.kt)("p",null,"The default allocation policy is the average allocation strategy, which is the most common strategy. Consumers within a Consumer Group under the average allocation strategy will consume equally according to a paging-like strategy."),(0,s.kt)("p",null,"With the average allocation strategy, the parallelism of consumption can be increased by expanding the number of consumers."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"\u6d88\u8d39\u8005\u6269\u5bb91",src:n(51217).Z,width:"1722",height:"1194"})),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"\u6d88\u8d39\u8005\u6269\u5bb92",src:n(36130).Z,width:"1716",height:"1226"})),(0,s.kt)("p",null,"However, it may not possible to increase the consumption ability by simply expanding the number of Consumers. For example, in the figure below, if the total queue number of Topic is less than the number of Consumers, the extra Consumers will not be assigned to the queue, and it will not be able to improve the consumption capacity even if there are more Consumers."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"\u6d88\u8d39\u8005\u6269\u5bb93",src:n(43478).Z,width:"1674",height:"752"})),(0,s.kt)("h2",{id:"consumer-offset"},"Consumer Offset"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"\u6d88\u8d39\u4f4d\u70b9",src:n(53648).Z,width:"1271",height:"942"})),(0,s.kt)("p",null,"As shown in the figure above, each queue in Apache RocketMQ records its own minimum and maximum offset. For Consumer Groups, there is also the concept of Consumer offsets. In Clustering mode, Consumer offsets are committed by the client and saved by the server. In contrast, Consumer offsets are saved by the client itself in Broadcasting mode. Normally the Consumer offsets are updated without message duplication, but if a Consumer crashes or a new Consumer joins the cluster, the load rebalancing will be triggered. After the rebalance is completed, each consumer may be assigned to a new queue instead of the previously processed queue. In order to be able to continue the previous work, the consumer needs to read the last submitted Consumer offset of each queue and then continue pulling messages from it. However, during the actual process, since the Consumer offsets submitted by the client to the server are not real-time, load rebalancing may result in a small number of duplicate messages."),(0,s.kt)("h2",{id:"push-pull-and-long-polling"},"Push, Pull, and Long Polling"),(0,s.kt)("p",null,"The consumption mode of Message Queue can be roughly divided into two kinds, which are Push and Pull."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Push mode is the server actively pushing messages to the client. The advantage is that the efficiency is better, but if the client does not run good flow control, once the server pushes a large number of messages to the client, it will cause the client messages to pile up or even crash."),(0,s.kt)("li",{parentName:"ul"},"Pull mode is the client needs to take the initiative to fetch data from the server. The advantage is that the client can consume according to its own consumption ability, but the frequency of pulling messages also needs to be controlled by the user. The frequent pull is possible to put pressure on the server and the client, and a long pull interval is easy to cause untimely consumption.")),(0,s.kt)("p",null,"Apache RocketMQ provides both Push mode and Pull mode."))}m.isMDXComponent=!0},77041:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/\u5e7f\u64ad\u6d88\u8d39\u6a21\u5f0f-59abf13c1dfde37423a4b9ac552dc1f3.png"},53648:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/\u6d88\u8d39\u4f4d\u70b9-3b0320b183d4318d6b75e3504027e436.png"},51217:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/\u6d88\u8d39\u8005\u6269\u5bb91-2409cbfb4077f47f2e473b18eb78656b.jpeg"},36130:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/\u6d88\u8d39\u8005\u6269\u5bb92-7d9c1d1dd8caea665a4a74b91f017560.jpeg"},43478:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/\u6d88\u8d39\u8005\u6269\u5bb93-65293ca6c2a01bf0a186821ba3432417.jpeg"},28068:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/\u96c6\u7fa4\u6d88\u8d39\u6a21\u5f0f-7f4462d200247db35ca90bb67df7c9b1.png"}}]);
# 基本概念

## 消息

RocketMQ消息构成非常简单。如下图所示，首先是topic，表示要发送的消息的主题，body表示消息的存储内容，properties表示消息属性，不管是RocketMQ的Tag过滤还是延迟消息等都会利用消息属性的能力，transactionId会在事务消息中使用。

![Message](picture/Message.png)

Message可以设置的属性值包括：

| 字段名         | 默认值 | 说明                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| Topic          | null   | 必填，消息所属topic的名称                                        |
| Body           | null   | 必填，消息体                                                 |
| Tags           | null   | 选填，消息标签，方便服务器过滤使用。目前只支持每个消息设置一个tag |
| Keys           | null   | 选填，代表这条消息的业务关键词，服务器会根据keys创建哈希索引，设置后，可以在Console系统根据Topic、Keys来查询消息，由于是哈希索引，请尽可能保证key唯一，例如订单号，商品Id等。 |
| Flag           | 0      | 选填，完全由应用来设置，RocketMQ不做干预                     |
| DelayTimeLevel | 0      | 选填，消息延时级别，0表示不延时，大于0会延时特定的时间才会被消费 |
| WaitStoreMsgOK | TRUE   | 选填，表示消息是否在服务器落盘后才返回应答。                 |

## Tag

本节介绍Apache RocketMQ的Tag，Topic与Tag都是业务上用来归类的标识，区分在于Topic是一级分类，而Tag可以理解为是二级分类。使用Tag可以实现对Topic中的消息进行过滤。

- Topic：消息主题，通过Topic对不同的业务消息进行分类。
- Tag：消息标签，用来进一步区分某个Topic下的消息分类，消息从生产者发出即带上的属性。

Topic和Tag的关系如下图所示。

![Tag](picture/Tag.png)

到底什么时候该用Topic，什么时候该用Tag？

可以从以下几个方面进行判断：

消息类型是否一致：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的Topic，无法通过Tag进行区分。

业务是否相关联：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的Topic进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用Tag进行区分。

消息优先级是否一致：如同样是物流消息，盒马必须小时内送达，天猫超市24小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的Topic进行区分。

消息量级是否相当：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的Topic。

总的来说，针对消息分类，您可以选择创建多个Topic，或者在同一个Topic下创建多个Tag。但通常情况下，不同的Topic之间的消息没有必然的联系，而Tag则用来区分同一个Topic下相互关联的消息，例如全集和子集的关系、流程先后的关系。

## Keys

Apache RocketMQ每个消息可以在业务层面的设置唯一标识码keys字段，方便将来定位消息丢失问题。 Broker端会为每个消息创建索引（哈希索引），应用可以通过topic、key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。

```java
   // 订单Id   
   String orderId = "20034568923546";   
   message.setKeys(orderId);   
```

## 队列

为了支持高并发和水平扩展，需要对Topic进行分区，在RocketMQ中这被称为队列，一个Topic可能有多个队列，并且可能分布在不同的Broker上。

![MessageQueue](picture/MessageQueue.png)

一般来说一条消息，如果没有重复发送（比如因为服务端没有响应而进行重试），则只会存在在Topic的其中一个队列中，消息在队列中按照先进先出的原则存储，每条消息会有自己的位点，每个队列会统计当前消息的总条数，这个称为最大位点MaxOffset；队列的起始位置对应的位置叫做起始位点MinOffset。队列可以提升消息发送和消费的并发度。

## 生产者

生产者（Producer）就是消息的发送者，Apache RocketMQ拥有丰富的消息类型，可以支持不用的应用场景，在不同的场景中，需要使用不同的消息进行发送。比如在电商交易中超时未支付关闭订单的场景，在订单创建时会发送一条延时消息。这条消息将会在30分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。如支付未完成，则关闭订单。如已完成支付则忽略，此时就需要用到延迟消息；电商场景中，业务上要求同一订单的消息保持严格顺序，此时就要用到顺序消息。在日志处理场景中，可以接受的比较大的发送延迟，但对吞吐量的要求很高，希望每秒能处理百万条日志，此时可以使用批量消息。在银行扣款的场景中，要保持上游的扣款操作和下游的短信通知保持一致，此时就要使用事务消息，下一节将会介绍各种类型消息的发送。
